devtools::install_github("amf71/cloneMap")
Clone_map( tree_example, CCFs_example )
library(cloneMap)
Clone_map( tree_example, CCFs_example )
library(cloneMap)
Clone_map( tree_example, CCFs_example )
detach("package:cloneMap", unload=TRUE)
library(cloneMap)
Clone_map( tree_example, CCFs_example )
detach("package:cloneMap", unload=TRUE)
library(cloneMap)
Clone_map( tree_example, CCFs_example )
detach("package:cloneMap", unload=TRUE)
library(cloneMap)
Clone_map( tree_example, CCFs_example )
detach("package:cloneMap", unload=TRUE)
library(cloneMap)
Clone_map( tree_example, CCFs_example )
detach("package:cloneMap", unload=TRUE)
library(cloneMap)
Clone_map( tree_example, CCFs_example )
options( error == browser)
options( error = browser)
Clone_map( tree_example, CCFs_example )
detach("package:cloneMap", unload=TRUE)
library(cloneMap)
Clone_map( tree_example, CCFs_example )
detach("package:cloneMap", unload=TRUE)
library(cloneMap)
Clone_map( tree_example, CCFs_example )
detach("package:cloneMap", unload=TRUE)
library(cloneMap)
Clone_map( tree_example, CCFs_example )
Clone_map( tree_example, CCFs_example )
# supress warning - gets max number of colours from pallette - none have > 12 #
getPalette <- suppressWarnings( colorRampPalette( RColorBrewer::brewer.pal( 12, brewer.palette) ) ) # brewer.palette specified in argumentss, default = "Paired"
clone.cols <- getPalette( length( clones ) )
names(clone.cols) <- clones
clones <- unique( as.numeric(c(tree.mat[,1], tree.mat[,2]) ) )
# order the tree so the trunk and earl clones are always the same colours accross tumours #
if( nrow(tree.mat) > 1 ) tree.mat <- amfFunctions::logically.order.tree(tree.mat)
tree.mat = tree_example
CCF.data <- CCFs_example
# order the tree so the trunk and earl clones are always the same colours accross tumours #
if( nrow(tree.mat) > 1 ) tree.mat <- amfFunctions::logically.order.tree(tree.mat)
tree.mat
clones <- unique( as.numeric(c(tree.mat[,1], tree.mat[,2]) ) )
clones
detach("package:cloneMap", unload=TRUE)
library(cloneMap)
Clone_map( tree_example, CCFs_example )
CCFs_example <- data.frame( clones = 1:11,
CCF = c(1, 0.4, 0.45, 0.05, 0.3, 0.15, 0.2, 0.1, 0.15, 0.07, 0.15) , stringsAsFactors = F)
CCFs_simple_example <- data.frame( clones = c(1, 2, 4, 5),
CCF = c(1, 0.4, 0.02, 0.2) , stringsAsFactors = F)
# tree matricies are written with each relaationship as a row, #
# the parent as the first column and child as th second        #
tree_example <- matrix( c(1, 2,
1, 3,
1, 4,
2, 5,
3, 7,
3, 8,
3, 9,
5, 11,
5, 6,
7, 10 ), ncol = 2, byrow = TRUE )
clones <- unique( as.numeric(c(tree_example[,1], tree_example[,2]) ) )
getPalette <- colorRampPalette( RColorBrewer::brewer.pal( 8, "Dark2") )
clone_colours_example <- getPalette( length( clones ) )
# OR #
clone_colours_example <- c( "#1B9E77", "#A07125", "#B16548", "#8068AE", "#D03792",
"#A66753", "#7FA718", "#D9AA04", "#BF8B12", "#927132",
"#666666" )
names(clone_colours_example) <- CCFs_example$clones
clone_colours_example
CCFs_example
tree_example
CCFs_example
tree_example
clone_colours_example
ls()
Clone_map( tree_example, CCFs_example )
tree.mat
CCF.data
# how many core do you have access to for parrelellisation? #
num_cores <- parallel::detectCores() / 2
Clone_map = NA; resolution.index = 100;
brewer.palette = "Paired"; smoothing.par = 10; clone.cols = NA;
output.Clone.map.obj = FALSE; plot.data = TRUE; border.thickness = 1.5;
border.colour = "grey20"; repeat.limit = 4; track = TRUE; high_qualty_mode = TRUE
# how many core do you have access to for parrelellisation? #
num_cores <- parallel::detectCores() / 2
# only worth parrellelising if > 10 cores, otheriwise actually slows code! - need to test further #
if( num_cores < 10 ) num_cores <- 1
# signpost #
cat( "formatting and cleaning input data...\n" )
clone_map_data_supplied <- !all( is.na(Clone_map) )
CFF_data_supplied <- !all( is.na(CCF.data) )
tree_data_supplied <- !all( is.na(tree.mat) )
if( !clone_map_data_supplied & !CFF_data_supplied & !CFF_data_supplied ) stop( "Please provide either a phylogenetics tree matric and a CCF table or a Clone_map object")
# if tree supplied in raster input then extract from here #
if( clone_map_data_supplied ){
# check class is correct (ie is it expected output from this function) #
if( ! class(Clone_map) == "Clone map" ) stop( "incorrect raster input" )
tree.mat <- Clone_map[[2]]
}
# make sure tree class is correct #
tree.mat <- as.matrix( tree.mat )
# get colours for plotting if these are not provided #
clone_colours_supplied <- !all( is.na(clone.cols) )
# order the tree so the trunk and earl clones are always the same colours accross tumours #
if( nrow(tree.mat) > 1 ) tree.mat <- amfFunctions::logically.order.tree(tree.mat)
clones <- unique( as.numeric(c(tree.mat[,1], tree.mat[,2]) ) )
#subset for clones also in CCF table
if( CFF_data_supplied ) clones <- clones[ clones %in% CCF.data$clones ]
# supress warning - gets max number of colours from pallette - none have > 12 #
getPalette <- suppressWarnings( colorRampPalette( RColorBrewer::brewer.pal( 12, brewer.palette) ) ) # brewer.palette specified in argumentss, default = "Paired"
clone.cols <- getPalette( length( clones ) )
names(clone.cols) <- clones
# ensure CCF.table is correct class #
CCF.data <- as.data.frame( CCF.data )
# remove any clones with estimated CCF of 0 in all regions #
CCF.data <- CCF.data[ CCF.data$CCF > 0 ,]
# limit CCF.table to clones on the tree #
# if this is the case print those which have been removed #
tree.clones <- unique( as.numeric(tree.mat) )
tree.clones
CCF.data$clones
CF.data$clones %in% tree.clones
options(error = NULL)
CCF.data$clones %in% tree.clones
all( CCF.data$clones %in% tree.clones )
!all( CCF.data$clones %in% tree.clones )
CCF.data <- CCF.data[ CCF.data$clones %in% tree.clones, ]
tree.clones %in% CCF.data$clones
!all( tree.clones %in% CCF.data$clones )
detach("package:cloneMap", unload=TRUE)
library(cloneMap)
Clone_map( tree_example, CCFs_example )
tree_example
CCFs_example
clone_colours_example
detach("package:cloneMap", unload=TRUE)
library(cloneMap)
Clone_map( tree_example, CCFs_example )
detach("package:cloneMap", unload=TRUE)
library(cloneMap)
Clone_map( tree_example, CCFs_example )
